#!/usr/bin/env python3

import sqlite3
import sys
import os
import time
import tempfile
import subprocess
from pathlib import Path
from datetime import datetime


def find_database_path():
    """
    Find the database path following the specification:
    1. Look for .timetracker directory walking up from current directory
    2. Fall back to $XDG_HOME/.local/state/timetracker/database.db
    """
    # First, check for .timetracker directory in current or parent directories
    current = Path.cwd()
    for parent in [current] + list(current.parents):
        timetracker_dir = parent / ".timetracker"
        if timetracker_dir.is_dir():
            return timetracker_dir / "database.db"

    # Fall back to XDG_HOME
    xdg_home = os.environ.get("XDG_HOME") or os.path.expanduser("~")
    db_dir = Path(xdg_home) / ".local" / "state" / "timetracker"
    db_dir.mkdir(parents=True, exist_ok=True)
    return db_dir / "database.db"


def init_database(db_path):
    """Initialize database schema if it doesn't exist."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Create tasks table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
            name TEXT NOT NULL UNIQUE,
            notes TEXT,
            archived BOOLEAN DEFAULT 0
        )
    """)

    # Create entries table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS entries (
            id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
            task_id INTEGER NOT NULL,
            start_at INTEGER NOT NULL,
            stop_at INTEGER,
            FOREIGN KEY (task_id) REFERENCES tasks(id)
        )
    """)

    conn.commit()
    conn.close()


def get_connection():
    """Get a database connection."""
    db_path = find_database_path()
    init_database(db_path)
    return sqlite3.connect(db_path)


def start_task(task_name):
    """Start a task - upsert task and create entry if not running."""
    # Validate task name is not "all" (reserved for stop all command)
    if task_name.lower() == "all":
        print(
            "Error: Task name 'all' is reserved for 'tt stop all' command",
            file=sys.stderr,
        )
        sys.exit(1)

    conn = get_connection()
    cursor = conn.cursor()

    # Upsert task
    cursor.execute(
        """
        INSERT INTO tasks (name, archived)
        VALUES (?, 0)
        ON CONFLICT(name) DO NOTHING
    """,
        (task_name,),
    )

    # Get task_id
    cursor.execute("SELECT id FROM tasks WHERE name = ?", (task_name,))
    task_id = cursor.fetchone()[0]

    # Check if already running
    cursor.execute(
        """
        SELECT id FROM entries
        WHERE task_id = ? AND stop_at IS NULL
    """,
        (task_id,),
    )

    if cursor.fetchone() is not None:
        # Already running - no-op
        conn.close()
        return

    # Start new entry
    current_time = int(time.time())
    cursor.execute(
        """
        INSERT INTO entries (task_id, start_at)
        VALUES (?, ?)
    """,
        (task_id, current_time),
    )

    conn.commit()
    conn.close()
    print(f"Started task: {task_name}")


def stop_task(task_name):
    """Stop a running task."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task_id
    cursor.execute("SELECT id FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id = result[0]

    # Find running entry
    cursor.execute(
        """
        SELECT id FROM entries
        WHERE task_id = ? AND stop_at IS NULL
    """,
        (task_id,),
    )

    entry = cursor.fetchone()
    if entry is None:
        conn.close()
        print(f"Error: Task '{task_name}' is not running", file=sys.stderr)
        sys.exit(1)

    # Stop the entry
    current_time = int(time.time())
    cursor.execute(
        """
        UPDATE entries
        SET stop_at = ?
        WHERE id = ?
    """,
        (current_time, entry[0]),
    )

    conn.commit()
    conn.close()
    print(f"Stopped task: {task_name}")


def stop_all_tasks():
    """Stop all currently running tasks."""
    conn = get_connection()
    cursor = conn.cursor()

    # Find all running entries
    cursor.execute("""
        SELECT t.name, e.id FROM entries e
        JOIN tasks t ON e.task_id = t.id
        WHERE e.stop_at IS NULL
        ORDER BY t.name
    """)

    running_tasks = cursor.fetchall()

    if not running_tasks:
        conn.close()
        print("No running tasks to stop")
        return

    current_time = int(time.time())
    stopped_count = 0

    # Stop all running entries
    for task_name, entry_id in running_tasks:
        cursor.execute(
            "UPDATE entries SET stop_at = ? WHERE id = ?", (current_time, entry_id)
        )
        print(f"Stopped task: {task_name}")
        stopped_count += 1

    conn.commit()
    conn.close()
    print(f"Stopped {stopped_count} running task(s)")


def note_task(task_name):
    """Edit notes for a task."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task
    cursor.execute("SELECT id, notes FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id, current_notes = result

    # Create temp file with current notes
    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as tf:
        temp_path = tf.name
        if current_notes:
            tf.write(current_notes)

    try:
        # Open in editor
        editor = os.environ.get("EDITOR", "vi")
        subprocess.run([editor, temp_path], check=True)

        # Read updated notes
        with open(temp_path, "r") as f:
            new_notes = f.read()

        # Update database
        cursor.execute(
            """
            UPDATE tasks
            SET notes = ?
            WHERE id = ?
        """,
            (new_notes, task_id),
        )

        conn.commit()
        print(f"Updated notes for task: {task_name}")
    finally:
        # Clean up temp file
        os.unlink(temp_path)
        conn.close()


def archive_task(task_name):
    """Archive a task and stop it if running."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task_id
    cursor.execute("SELECT id FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id = result[0]

    # Stop running entry if exists
    current_time = int(time.time())
    cursor.execute(
        """
        UPDATE entries
        SET stop_at = ?
        WHERE task_id = ? AND stop_at IS NULL
    """,
        (current_time, task_id),
    )

    # Archive task
    cursor.execute(
        """
        UPDATE tasks
        SET archived = 1
        WHERE id = ?
    """,
        (task_id,),
    )

    conn.commit()
    conn.close()
    print(f"Archived task: {task_name}")


def format_duration(seconds):
    """Format duration in seconds to 'Xhr Ym' format."""
    if seconds < 60:
        return "0m"

    hours = seconds // 3600
    minutes = (seconds % 3600) // 60

    if hours > 0:
        return f"{hours}hr {minutes}m"
    else:
        return f"{minutes}m"


def list_tasks(show_all=False):
    """List tasks. If show_all is True, include archived tasks."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get tasks based on show_all flag
    if show_all:
        cursor.execute("""
            SELECT id, name, archived FROM tasks
            ORDER BY name ASC
        """)
    else:
        cursor.execute("""
            SELECT id, name, archived FROM tasks
            WHERE archived = 0
            ORDER BY name ASC
        """)

    tasks = cursor.fetchall()

    if not tasks:
        conn.close()
        return

    for task_id, task_name, is_archived in tasks:
        # Check if running
        cursor.execute(
            """
            SELECT id FROM entries
            WHERE task_id = ? AND stop_at IS NULL
        """,
            (task_id,),
        )
        is_running = cursor.fetchone() is not None

        # Calculate total time spent
        cursor.execute(
            """
            SELECT start_at, stop_at FROM entries
            WHERE task_id = ?
        """,
            (task_id,),
        )

        total_seconds = 0
        for start_at, stop_at in cursor.fetchall():
            if stop_at is None:
                # Still running
                total_seconds += int(time.time()) - start_at
            else:
                total_seconds += stop_at - start_at

        # Format output with new checkbox style
        if is_archived:
            marker = "x"
        elif is_running:
            marker = "~"
        else:
            marker = " "

        time_str = format_duration(total_seconds)
        print(f"[{marker}] {task_name} --- {time_str}")

    conn.close()


def show_task(task_name):
    """Show details about a task."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task
    cursor.execute("SELECT id, notes FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id, notes = result

    # Check if running
    cursor.execute(
        """
        SELECT id FROM entries
        WHERE task_id = ? AND stop_at IS NULL
    """,
        (task_id,),
    )
    is_running = cursor.fetchone() is not None

    # Print header
    running_text = " *running*" if is_running else ""
    print(f"{task_name}{running_text}")
    print()

    # Print notes if present
    if notes and notes.strip():
        print(notes)
        print()

    # Calculate total time
    cursor.execute(
        """
        SELECT start_at, stop_at FROM entries
        WHERE task_id = ?
        ORDER BY start_at ASC
    """,
        (task_id,),
    )

    entries = cursor.fetchall()
    total_seconds = 0

    for start_at, stop_at in entries:
        if stop_at is None:
            total_seconds += int(time.time()) - start_at
        else:
            total_seconds += stop_at - start_at

    # Print entries table
    if entries:
        print("| Start At            | Stop At             | Elapsed |")
        print("| ------------------- | ------------------- | ------- |")

        for start_at, stop_at in entries:
            start_str = datetime.fromtimestamp(start_at).strftime("%Y-%m-%d %H:%M:%S")
            stop_str = (
                datetime.fromtimestamp(stop_at).strftime("%Y-%m-%d %H:%M:%S")
                if stop_at
                else ""
            )

            # Calculate elapsed time for this entry
            if stop_at is None:
                elapsed_seconds = int(time.time()) - start_at
            else:
                elapsed_seconds = stop_at - start_at

            elapsed_str = format_duration(elapsed_seconds)
            print(f"| {start_str} | {stop_str:19} | {elapsed_str:7} |")

        # Print total row
        print(
            "| Total               |                     | {:<7} |".format(
                format_duration(total_seconds)
            )
        )
    else:
        print("No entries yet.")

    conn.close()


def cancel_task(task_name):
    """Cancel running task and delete running entry."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task_id
    cursor.execute("SELECT id FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id = result[0]

    # Find running entry
    cursor.execute(
        """
        SELECT id FROM entries
        WHERE task_id = ? AND stop_at IS NULL
    """,
        (task_id,),
    )

    entry = cursor.fetchone()
    if entry is None:
        conn.close()
        print(f"Error: Task '{task_name}' is not running", file=sys.stderr)
        sys.exit(1)

    # Delete the running entry
    cursor.execute(
        """
        DELETE FROM entries
        WHERE id = ?
    """,
        (entry[0],),
    )

    conn.commit()
    conn.close()
    print(f"Cancelled task: {task_name}")


def delete_task(task_name):
    """Delete a task and all its entries."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task_id
    cursor.execute("SELECT id FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id = result[0]

    # Delete all entries for this task
    cursor.execute(
        """
        DELETE FROM entries
        WHERE task_id = ?
    """,
        (task_id,),
    )

    # Delete the task
    cursor.execute(
        """
        DELETE FROM tasks
        WHERE id = ?
    """,
        (task_id,),
    )

    conn.commit()
    conn.close()
    print(f"Deleted task: {task_name}")


def edit_task(task_name):
    """Edit a task name and its entries interactively."""
    conn = get_connection()
    cursor = conn.cursor()

    # Get task
    cursor.execute("SELECT id, name FROM tasks WHERE name = ?", (task_name,))
    result = cursor.fetchone()

    if result is None:
        conn.close()
        print(f"Error: Task '{task_name}' not found", file=sys.stderr)
        sys.exit(1)

    task_id, current_name = result

    # Get all entries for this task
    cursor.execute(
        """
        SELECT id, start_at, stop_at FROM entries
        WHERE task_id = ?
        ORDER BY start_at ASC
    """,
        (task_id,),
    )
    entries = cursor.fetchall()

    # Create temp file with current task and entries
    with tempfile.NamedTemporaryFile(mode="w", suffix=".txt", delete=False) as tf:
        temp_path = tf.name

        # Write task name as first line
        tf.write(f"{current_name}\n")

        # Write entries
        for entry_id, start_at, stop_at in entries:
            start_str = datetime.fromtimestamp(start_at).strftime("%Y-%m-%d %H:%M:%S")
            if stop_at is None:
                tf.write(f"edit {entry_id} {start_str} running\n")
            else:
                stop_str = datetime.fromtimestamp(stop_at).strftime("%Y-%m-%d %H:%M:%S")
                tf.write(f"edit {entry_id} {start_str} to {stop_str}\n")

        # Write help text at the bottom
        tf.write("\n")
        tf.write("# Commands:\n")
        tf.write("#   edit <ID> <START> to <STOP>       - Edit an existing entry\n")
        tf.write("#   edit <ID> <START> running         - Mark entry as running\n")
        tf.write("#   add <START> to <STOP>             - Add new completed entry\n")
        tf.write("#   add <START> running               - Add new running entry\n")
        tf.write("#   delete <ID>                       - Delete an entry\n")
        tf.write("#\n")
        tf.write("# Shortcuts: e=edit, a=add, d=delete\n")
        tf.write("# Only the last entry can be 'running'\n")
        tf.write("# Times must be in format: YYYY-MM-DD HH:MM:SS\n")

    try:
        # Open in editor
        editor = os.environ.get("EDITOR", "vi")
        subprocess.run([editor, temp_path], check=True)

        # Read edited file
        with open(temp_path, "r") as f:
            lines = f.readlines()

        # Parse the edited file
        if not lines:
            print("Error: Empty file", file=sys.stderr)
            conn.close()
            sys.exit(1)

        new_task_name = lines[0].strip()
        if not new_task_name:
            print("Error: Task name cannot be empty", file=sys.stderr)
            conn.close()
            sys.exit(1)

        # Parse commands
        edits = []  # (entry_id, start_timestamp, stop_timestamp_or_none)
        adds = []  # (start_timestamp, stop_timestamp_or_none)
        deletes = []  # entry_id

        running_count = 0
        last_line_running = False

        for line_num, line in enumerate(lines[1:], start=2):
            line = line.strip()

            # Skip empty lines and comments
            if not line or line.startswith("#"):
                continue

            parts = line.split(None, 1)  # Split on first whitespace
            if not parts:
                continue

            command = parts[0].lower()
            rest = parts[1] if len(parts) > 1 else ""

            # Track if this is the last non-comment line
            is_last_line = True
            for future_line in lines[line_num:]:
                future_stripped = future_line.strip()
                if future_stripped and not future_stripped.startswith("#"):
                    is_last_line = False
                    break

            try:
                if command in ("edit", "e"):
                    # Parse: edit <ID> <START> to <STOP> OR edit <ID> <START> running
                    parts = rest.split(None, 4)
                    if len(parts) < 3:
                        print(
                            f"Error: Line {line_num}: Invalid edit format",
                            file=sys.stderr,
                        )
                        conn.close()
                        sys.exit(1)

                    entry_id = int(parts[0])
                    start_date = parts[1]
                    start_time = parts[2]
                    start_str = f"{start_date} {start_time}"

                    # Parse start timestamp
                    start_dt = datetime.strptime(start_str, "%Y-%m-%d %H:%M:%S")
                    start_ts = int(start_dt.timestamp())

                    if len(parts) >= 4 and parts[3].lower() == "running":
                        stop_ts = None
                        running_count += 1
                        if is_last_line:
                            last_line_running = True
                        else:
                            print(
                                f"Error: Line {line_num}: Only the last entry can be marked 'running'",
                                file=sys.stderr,
                            )
                            conn.close()
                            sys.exit(1)
                    elif len(parts) >= 5 and parts[3].lower() == "to":
                        stop_date = parts[4].split()[0]
                        stop_time = (
                            parts[4].split()[1]
                            if len(parts[4].split()) > 1
                            else "00:00:00"
                        )
                        stop_str = f"{stop_date} {stop_time}"
                        stop_dt = datetime.strptime(stop_str, "%Y-%m-%d %H:%M:%S")
                        stop_ts = int(stop_dt.timestamp())

                        if stop_ts <= start_ts:
                            print(
                                f"Error: Line {line_num}: Stop time must be after start time",
                                file=sys.stderr,
                            )
                            conn.close()
                            sys.exit(1)
                    else:
                        print(
                            f"Error: Line {line_num}: Invalid edit format",
                            file=sys.stderr,
                        )
                        conn.close()
                        sys.exit(1)

                    edits.append((entry_id, start_ts, stop_ts))

                elif command in ("add", "a"):
                    # Parse: add <START> to <STOP> OR add <START> running
                    parts = rest.split(None, 3)
                    if len(parts) < 3:
                        print(
                            f"Error: Line {line_num}: Invalid add format",
                            file=sys.stderr,
                        )
                        conn.close()
                        sys.exit(1)

                    start_date = parts[0]
                    start_time = parts[1]
                    start_str = f"{start_date} {start_time}"

                    # Parse start timestamp
                    start_dt = datetime.strptime(start_str, "%Y-%m-%d %H:%M:%S")
                    start_ts = int(start_dt.timestamp())

                    if parts[2].lower() == "running":
                        stop_ts = None
                        running_count += 1
                        if is_last_line:
                            last_line_running = True
                        else:
                            print(
                                f"Error: Line {line_num}: Only the last entry can be marked 'running'",
                                file=sys.stderr,
                            )
                            conn.close()
                            sys.exit(1)
                    elif parts[2].lower() == "to" and len(parts) >= 4:
                        stop_date = parts[3].split()[0]
                        stop_time = (
                            parts[3].split()[1]
                            if len(parts[3].split()) > 1
                            else "00:00:00"
                        )
                        stop_str = f"{stop_date} {stop_time}"
                        stop_dt = datetime.strptime(stop_str, "%Y-%m-%d %H:%M:%S")
                        stop_ts = int(stop_dt.timestamp())

                        if stop_ts <= start_ts:
                            print(
                                f"Error: Line {line_num}: Stop time must be after start time",
                                file=sys.stderr,
                            )
                            conn.close()
                            sys.exit(1)
                    else:
                        print(
                            f"Error: Line {line_num}: Invalid add format",
                            file=sys.stderr,
                        )
                        conn.close()
                        sys.exit(1)

                    adds.append((start_ts, stop_ts))

                elif command in ("delete", "d"):
                    # Parse: delete <ID>
                    parts = rest.split(None, 1)
                    if not parts:
                        print(
                            f"Error: Line {line_num}: Missing entry ID for delete",
                            file=sys.stderr,
                        )
                        conn.close()
                        sys.exit(1)

                    entry_id = int(parts[0])
                    deletes.append(entry_id)

                else:
                    print(
                        f"Error: Line {line_num}: Invalid command '{command}'. Use edit, add, or delete.",
                        file=sys.stderr,
                    )
                    conn.close()
                    sys.exit(1)

            except ValueError as e:
                print(f"Error: Line {line_num}: Invalid format - {e}", file=sys.stderr)
                conn.close()
                sys.exit(1)

        # Validate running count
        if running_count > 1:
            print(
                f"Error: Multiple entries marked 'running' (only one allowed)",
                file=sys.stderr,
            )
            conn.close()
            sys.exit(1)

        # Check for task name conflict if renamed
        if new_task_name != current_name:
            cursor.execute("SELECT id FROM tasks WHERE name = ?", (new_task_name,))
            if cursor.fetchone() is not None:
                print(
                    f"Error: Task name '{new_task_name}' already exists. Cannot rename.",
                    file=sys.stderr,
                )
                conn.close()
                sys.exit(1)

        # Verify all edit/delete entry IDs exist
        valid_entry_ids = {e[0] for e in entries}
        for entry_id, _, _ in edits:
            if entry_id not in valid_entry_ids:
                print(f"Error: Entry ID {entry_id} not found", file=sys.stderr)
                conn.close()
                sys.exit(1)
        for entry_id in deletes:
            if entry_id not in valid_entry_ids:
                print(f"Error: Entry ID {entry_id} not found", file=sys.stderr)
                conn.close()
                sys.exit(1)

        # Everything validated - now execute in transaction
        try:
            # Rename task if needed
            if new_task_name != current_name:
                cursor.execute(
                    "UPDATE tasks SET name = ? WHERE id = ?", (new_task_name, task_id)
                )

            # Process deletes
            for entry_id in deletes:
                cursor.execute("DELETE FROM entries WHERE id = ?", (entry_id,))

            # Process edits
            for entry_id, start_ts, stop_ts in edits:
                cursor.execute(
                    "UPDATE entries SET start_at = ?, stop_at = ? WHERE id = ?",
                    (start_ts, stop_ts, entry_id),
                )

            # Process adds
            for start_ts, stop_ts in adds:
                cursor.execute(
                    "INSERT INTO entries (task_id, start_at, stop_at) VALUES (?, ?, ?)",
                    (task_id, start_ts, stop_ts),
                )

            conn.commit()

            # Print summary
            running_text = f", {running_count} running" if running_count > 0 else ""
            completed = len(edits) + len(adds) - running_count
            print(
                f"Saved {len(edits) + len(adds)} entries ({completed} completed{running_text})"
            )
            if len(deletes) > 0:
                print(f"Deleted {len(deletes)} entries")
            if new_task_name != current_name:
                print(f"Renamed task: '{current_name}' â†’ '{new_task_name}'")

        except Exception as e:
            conn.rollback()
            print(f"Error: Failed to save changes - {e}", file=sys.stderr)
            sys.exit(1)

    finally:
        # Clean up temp file
        os.unlink(temp_path)
        conn.close()


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: tt <command> [args]", file=sys.stderr)
        print("", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("  start <TASK NAME>    Start tracking a task", file=sys.stderr)
        print(
            "  stop <TASK NAME|all> Stop tracking a task (or all tasks)",
            file=sys.stderr,
        )
        print("  note <TASK NAME>     Edit task notes in $EDITOR", file=sys.stderr)
        print(
            "  edit <TASK NAME>     Edit task name and entries in $EDITOR",
            file=sys.stderr,
        )
        print(
            "  archive <TASK NAME>  Archive a task (stops if running)", file=sys.stderr
        )
        print(
            "  cancel <TASK NAME>   Cancel running task and delete the entry",
            file=sys.stderr,
        )
        print(
            "  delete <TASK NAME>   Delete task and all entries permanently",
            file=sys.stderr,
        )
        print("  ls                   List all unarchived tasks", file=sys.stderr)
        print(
            "  ls -a                List all tasks including archived", file=sys.stderr
        )
        print(
            "  show <TASK NAME>     Show task details with time entries",
            file=sys.stderr,
        )
        sys.exit(1)

    command = sys.argv[1]

    if command == "start":
        if len(sys.argv) < 3:
            print("Usage: tt start <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        start_task(task_name)

    elif command == "stop":
        if len(sys.argv) < 3:
            print("Usage: tt stop <TASK NAME|all>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        if task_name.lower() == "all":
            stop_all_tasks()
        else:
            stop_task(task_name)

    elif command == "note":
        if len(sys.argv) < 3:
            print("Usage: tt note <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        note_task(task_name)

    elif command == "archive":
        if len(sys.argv) < 3:
            print("Usage: tt archive <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        archive_task(task_name)

    elif command == "ls":
        # Check for -a flag
        show_all = len(sys.argv) > 2 and sys.argv[2] == "-a"
        list_tasks(show_all)

    elif command == "show":
        if len(sys.argv) < 3:
            print("Usage: tt show <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        show_task(task_name)

    elif command == "cancel":
        if len(sys.argv) < 3:
            print("Usage: tt cancel <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        cancel_task(task_name)

    elif command == "delete":
        if len(sys.argv) < 3:
            print("Usage: tt delete <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        delete_task(task_name)

    elif command == "edit":
        if len(sys.argv) < 3:
            print("Usage: tt edit <TASK NAME>", file=sys.stderr)
            sys.exit(1)
        task_name = " ".join(sys.argv[2:])
        edit_task(task_name)

    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("  start <TASK NAME>    Start tracking a task", file=sys.stderr)
        print(
            "  stop <TASK NAME|all> Stop tracking a task (or all tasks)",
            file=sys.stderr,
        )
        print("  note <TASK NAME>     Edit task notes in $EDITOR", file=sys.stderr)
        print(
            "  edit <TASK NAME>     Edit task name and entries in $EDITOR",
            file=sys.stderr,
        )
        print(
            "  archive <TASK NAME>  Archive a task (stops if running)", file=sys.stderr
        )
        print(
            "  cancel <TASK NAME>   Cancel running task and delete the entry",
            file=sys.stderr,
        )
        print(
            "  delete <TASK NAME>   Delete task and all entries permanently",
            file=sys.stderr,
        )
        print(
            "  ls                   List all tasks including archived", file=sys.stderr
        )
        print(
            "  ls -a                List all tasks including archived", file=sys.stderr
        )
        print(
            "  show <TASK NAME>     Show task details with time entries",
            file=sys.stderr,
        )
        sys.exit(1)


if __name__ == "__main__":
    main()
